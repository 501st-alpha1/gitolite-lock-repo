#!/usr/bin/perl
use strict;
use warnings;

use Getopt::Long;

use lib $ENV{GL_LIBDIR};
use Gitolite::Rc;
use Gitolite::Common;
use Gitolite::Conf::Load;

use constant CMD_LOCK   => 'lock';
use constant CMD_UNLOCK => 'unlock';
use constant CMD_BREAK  => 'break';
use constant CMD_STATUS => 'status';

use constant LOCK_FILE => "gl-lockrepo";

# TODO remove .git from CLI option, if given ( --lock foo.git -> --lock foo)

=for usage
Locks a whole repo to prevent pushing into it from any users, but the user which
locked the repo. Only the issuer of the lock can unlock the repo. Any user with
force rights (+) can break the lock of other users.

Usage

  ssh git@host lock-repo --lock   <repo> [--message <message>]
  ssh git@host lock-repo --unlock <repo>
  ssh git@host lock-repo --break  <repo> [--message <message>]
  ssh git@host lock-repo --status <repo>
  ssh git@host lock-repo --help

Options

  --lock|-l <repo>          Locks a repo for the user which invoked the command.
                            The repo must exist and the user need appropriate
                            access rights.
  --unlock|-u <repo>        Unlocks a repo. This is only possible for the user
                            which performed the previous lock.
  --break|-b <repo>         Breaks the lock of an other user. The user which
                            invokes this command need + right for that repo.
  --status|-s <repo>        Returns if the repo is locked or not.
  --message|-m <message>    Optional message. Combineable with --lock and --break.
                            This message will be displayed to users which try to
                            push to a locked repo.
  -help|-h                  Shows this help.

You MUST NOT combine --lock, --unlock and/or --break together in one command
invocation. That seems to be obvious, right?

Update hook

So that this comamnd affects the push the companion update hook needs to be
enabled. To enable it for everybody in all repository you can add this at
the bottom of your gitolite.conf:

  repo @all
      -   VREF/lock-repo  =   @all

FAQ

 Q: What should I do, if repo can't be unlocked?
 A: The lock information is stored in the bare repository in the file "gl-lockrepo".
    If you remove the file the repo is unlocked. That you can't unlock a repo
    may only happen due to bug. So for debugging it may be helpfull to keep a
    backup of that file.

Bugs

Bugs you can report to https://github.com/Weltraumschaf/gitolite/issues
=cut

usage() if not @ARGV or $ARGV[0] eq '-h' or $ARGV[0] eq '--help';
$ENV{GL_USER} or _die "GL_USER not set";

my $lockRepo   = '';
my $unlockRepo = '';
my $breakRepo  = '';
my $statusRepo = '';
my @messageParts;

GetOptions(
    "lock=s"        => \$lockRepo,
    "unlock=s"      => \$unlockRepo,
    "break=s"       => \$breakRepo,
    "status=s"      => \$statusRepo,
    "message=s{1,}" => \@messageParts
) or _die("Error in command line arguments!\n");

my $message = join( ' ', @messageParts );
my $op      = '';
my $repo    = '';

if ($lockRepo) {
    $op   = CMD_LOCK;
    $repo = $lockRepo;
}
elsif ($unlockRepo) {
    $op   = CMD_UNLOCK;
    $repo = $unlockRepo;
}
elsif ($breakRepo) {
    $op   = CMD_BREAK;
    $repo = $breakRepo;
}
elsif ($statusRepo) {
    $op   = CMD_STATUS;
    $repo = $statusRepo;
}

usage() if not $op;

if ( substr( $repo, -4 ) eq '.git' ) {

    # Remove trailing .git because access right check will fail with it.
    $repo = substr( $repo, 0, rindex( $repo, q{.} ) );
}
_die "You are not authorised"
  if access( $repo, $ENV{GL_USER}, 'W', 'any' ) =~ /DENIED/;
_die "You are not authorised"
  if $op eq CMD_BREAK
      and access( $repo, $ENV{GL_USER}, '+', 'any' ) =~ /DENIED/;

_chdir( $ENV{GL_REPO_BASE} );
_chdir("$repo.git")
  ;    # .Git is only on the file system, not for the rights checking above!

if ( $op eq CMD_LOCK ) {
    f_lock( $repo, $message );
}
elsif ( $op eq CMD_UNLOCK ) {
    f_unlock($repo);
}
elsif ( $op eq CMD_BREAK ) {
    f_break( $repo, $message );
}
elsif ( $op eq CMD_STATUS ) {
    f_status($repo);
}

# ----------------------------------------------------------------------
# everything below assumes we have already chdir'd to "$repo.git".

sub f_lock {
    my ( $repo, $message ) = @_;

    my %lock = get_lock();

    if ( $lock{USER} ) {
        _die "Repo '$repo' locked by '$lock{USER}' since "
          . localtime( $lock{TIME} )
          . " with message: $lock{MESSAGE}";
    }

    $lock{USER}    = $ENV{GL_USER};
    $lock{TIME}    = time;
    $lock{MESSAGE} = $message;
    put_lock(%lock);
    say "Repo locked for '$ENV{GL_USER}'.";
}

sub f_unlock {
    my ($repo) = @_;

    my %lock = get_lock();

    _die "Repo '$repo' was not locked!" unless $lock{USER};

    if ( $lock{USER} ne $ENV{GL_USER} ) {
        _die
          "Repo '${repo}' not locked by '$ENV{GL_USER}' but by '$lock{USER}'!";
    }

    delete $lock{USER};
    delete $lock{TIME};
    delete $lock{MESSAGE};
    put_lock(%lock);
    say "Repo unlocked.";
}

sub f_break {
    my ( $repo, $message ) = @_;

    my %lock = get_lock();

    _die "Repo '$repo' was not locked!" unless $lock{USER};

    my $user = $lock{USER};
    my $now  = localtime(time);
    my $time = -1;

    if ( defined( $lock{TIME} ) ) {
        $time = localtime( $lock{TIME} );
    }

    push @{ $lock{BREAKS} },
      "${now} $ENV{GL_USER} broke lock: ${user} ${time} with: ${message}";
    delete $lock{USER};
    delete $lock{TIME};
    delete $lock{MESSAGE};
    put_lock(%lock);
    say "Repo lock from '$user' broken.";
}

sub f_status {
    my ($repo) = @_;

    my %lock = get_lock();

    if ( $lock{USER} ) {
        my $time = -1;

        if ( defined( $lock{TIME} ) ) {
            $time = localtime( $lock{TIME} );
        }

        my $mesage = "";

        if ( defined( $lock{MESSAGE} ) ) {
            $mesage = $lock{MESSAGE};
        }

        say
"Repository locked by '$lock{USER}' since ${time} with message: ${mesage} ";
    }
    else {
        say "Repo '${repo}' is not locked.";
    }
}

sub get_lock {
    if ( -f LOCK_FILE ) {
        our %lock;

        my $t = slurp(LOCK_FILE);
        eval $t; ## no critic
        _die "Do '"
          . LOCK_FILE
          . "' failed with '$@', contact your administrator!"
          if $@;

        return %lock;
    }

    return ();
}

sub put_lock {
    my %lock = @_;

    use Data::Dumper;
    $Data::Dumper::Indent   = 1;
    $Data::Dumper::Sortkeys = 1;

    my $dumped_data = Data::Dumper->Dump( [ \%lock ], [qw(*lock)] );
    _print( LOCK_FILE, $dumped_data );
}
