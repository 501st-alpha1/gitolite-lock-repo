#!/usr/bin/perl
use strict;
use warnings;

use Getopt::Long;

use lib $ENV{GL_LIBDIR};
use Gitolite::Rc;
use Gitolite::Common;
use Gitolite::Conf::Load;

use constant CMD_LOCK   => 'lock';
use constant CMD_UNLOCK => 'unlock';
use constant CMD_BREAK  => 'break';

use constant LOCK_FILE => "gl-lockrepo";

=for usage
Locks a whole repo to prevent pushing into it from any users but the user which
lcoked the repo. Only the issuer of the lock can unlock the repo. Any user with
force rights (+) can break the lock of other users.

Usage:
    ssh git@host lock-repo --lock   <repo> [--message "<message>"]
    ssh git@host lock-repo --unlock <repo> [--message "<message>"]
    ssh git@host lock-repo --break  <repo> [--message "<message>"]
    ssh git@host lock-repo -h

Options:
    --lock <repo>           Locks a repo for the user which invoked the command.
                            The repo must exist and the user need appropriate
                            access rights.
    --unlock <repo>         Unlocks a repo. This is only possible for the user
                            which performed the previous lock.
    --break <repo>          Breaks the lock of an other user. The user which
                            invokes this command need + right for that repo.
    --message "<message>"   Optional message. Combineable with --lock, --unlock
                            and --break. This message will be displayed to users
                            which try to push to a locked repo.
    -h|--help|-?            Shows this help.

You must not combine --lock, --unlock and/or --break together in one command
invocation. That seems to be obvious, right?
=cut

usage() if not @ARGV or $ARGV[0] eq '-h' or $ARGV[0] eq '--help' or $ARGV[0] eq '-?';
$ENV{GL_USER} or _die "GL_USER not set";

my $lockRepo    = '';
my $unlockRepo  = '';
my $breakRepo   = '';
my $message     = '';

GetOptions ("lock=s"    => \$lockRepo,
            "unlock=s"  => \$unlockRepo,
            "break=s"   => \$breakRepo,
            "message=s" => \$message)
or _die("Error in command line arguments!\n");

my $op = '';
my $repo = '';

if ( $lockRepo ) {
    $op = CMD_LOCK;
    $repo = $lockRepo;
} elsif ( $unlockRepo ) {
    $op = CMD_UNLOCK;
    $repo = $unlockRepo;
} elsif ( $breakRepo ) {
    $op = CMD_BREAK;
    $repo = $breakRepo;
}

usage() if not $op;

_die "You are not authorised" if access( $repo, $ENV{GL_USER}, 'W', 'any' ) =~ /DENIED/;
_die "You are not authorised" if $op eq CMD_BREAK and access( $repo, $ENV{GL_USER}, '+', 'any' ) =~ /DENIED/;

_chdir( $ENV{GL_REPO_BASE} );
_chdir("$repo.git");

if ( $op eq CMD_LOCK ) {
    f_lock( $repo, $message );
} elsif ( $op eq CMD_UNLOCK ) {
    f_unlock( $repo, $message );
} elsif ( $op eq CMD_BREAK ) {
    f_break( $repo, $message );
}

# ----------------------------------------------------------------------
# everything below assumes we have already chdir'd to "$repo.git".

sub f_lock {
    my ( $repo, $message ) = @_;

    my %lock = get_lock();
    _die "'$repo' locked by '$lock{USER}' since " . localtime( $lock{TIME} ) if $lock{USER};
    $lock{USER}    = $ENV{GL_USER};
    $lock{TIME}    = time;
    $lock{MESSAGE} = $message;
    put_lock(%lock);
}

sub f_unlock {
    my ( $repo, $message ) = @_;

    my %lock = get_lock();
    _die "'$repo' not locked by '$ENV{GL_USER}'" if ( $lock{USER} || '' ) ne $ENV{GL_USER};
    delete $lock{USER};
    delete $lock{TIME};
    delete $lock{MESSAGE};
    put_lock(%lock);
}

sub f_break {
    my ( $repo, $message ) = @_;

    my %lock = get_lock();
    _die "'$repo' was not locked" unless $lock{USER};
    push @{ $lock{BREAKS} }, time . " $ENV{GL_USER} $lock{USER} $lock{TIME}";
    delete $lock{USER};
    delete $lock{TIME};
    delete $lock{MESSAGE};
    put_lock(%lock);
}

sub get_lock {
    if ( -f LOCK_FILE ) {
        our %lock;

        my $t = slurp(LOCK_FILE);
        eval $t;
        _die "do '" . LOCK_FILE . "' failed with '$@', contact your administrator" if $@;

        return %lock;
    }

    return ();
}

sub put_lock {
    my %lock = @_;

    use Data::Dumper;
    $Data::Dumper::Indent   = 1;
    $Data::Dumper::Sortkeys = 1;

    my $dumped_data = Data::Dumper->Dump( [ \%lock ], [qw(*lock)] );
    _print( LOCK_FILE, $dumped_data );
}
