#!/usr/bin/perl
use strict;
use warnings;

use Getopt::Long;

use lib $ENV{GL_LIBDIR};
use Gitolite::Rc;
use Gitolite::Common;
use Gitolite::Conf::Load;

use constant CMD_LOCK   => 'lock';
use constant CMD_UNLOCK => 'unlock';
use constant CMD_BREAK  => 'break';

use constant LOCK_FILE => "gl-lockrepo";

# gitolite command to lock and unlock whole repository to prevent push and deal with locks.

=for usage
Usage:  ssh git@host lock-repo --lock   <repo> --message "<message>"  # lock repo
        ssh git@host lock-repo --unlock <repo> --message "<message>"  # unlock repo
        ssh git@host lock-repo --break  <repo> --message "<message>"  # break lock of others (need +)
        ssh git@host lock-repo --help                                 # show this usage
=cut

usage() if not @ARGV or $ARGV[0] eq '-h';
$ENV{GL_USER} or _die "GL_USER not set";

my $lockRepo    = '';
my $unlockRepo  = '';
my $breakRepo   = '';
my $message     = '';

GetOptions ("lock"    => \$lockRepo,
            "unlock"  => \$unlockRepo,
            "break"   => \$breakRepo,
            "message" => \$message)
or _die("Error in command line arguments!\n");

my $op = '';
my $repo = '';

if ( $lockRepo ) {
    $op = CMD_LOCK;
    $repo = $lockRepo;
} elsif ( $unlockRepo ) {
    $op = CMD_UNLOCK;
    $repo = $unlockRepo;
} elsif ( $breakRepo ) {
    $op = CMD_BREAK;
    $repo = $breakRepo;
}

usage() if not $op;

_die "You are not authorised" if access( $repo, $ENV{GL_USER}, 'W', 'any' ) =~ /DENIED/;
_die "You are not authorised" if $op eq CMD_BREAK and access( $repo, $ENV{GL_USER}, '+', 'any' ) =~ /DENIED/;

_chdir( $ENV{GL_REPO_BASE} );
_chdir("$repo.git");

if ( $op eq CMD_LOCK ) {
    f_lock( $repo, $message );
} elsif ( $op eq CMD_UNLOCK ) {
    f_unlock( $repo, $message );
} elsif ( $op eq CMD_BREAK ) {
    f_break( $repo, $message );
}

# ----------------------------------------------------------------------
# everything below assumes we have already chdir'd to "$repo.git".

sub f_lock {
    my ( $repo, $message ) = @_;

    my %lock = get_lock();
    _die "'$repo' locked by '$lock{USER}' since " . localtime( $lock{TIME} ) if $lock{USER};
    $lock{USER}    = $ENV{GL_USER};
    $lock{TIME}    = time;
    $lock{MESSAGE} = $message;
    put_lock(%lock);
}

sub f_unlock {
    my ( $repo, $message ) = @_;

    my %lock = get_lock();
    _die "'$repo' not locked by '$ENV{GL_USER}'" if ( $lock{USER} || '' ) ne $ENV{GL_USER};
    delete $lock{USER};
    delete $lock{TIME};
    delete $lock{MESSAGE};
    put_lock(%lock);
}

sub f_break {
    my ( $repo, $message ) = @_;

    my %lock = get_lock();
    _die "'$repo' was not locked" unless $lock{USER};
    push @{ $lock{BREAKS} }, time . " $ENV{GL_USER} $lock{USER} $lock{TIME}";
    delete $lock{USER};
    delete $lock{TIME};
    delete $lock{MESSAGE};
    put_lock(%lock);
}

sub get_lock {
    if ( -f LOCK_FILE ) {
        our %lock;

        my $t = slurp(LOCK_FILE);
        eval $t;
        _die "do '" . LOCK_FILE . "' failed with '$@', contact your administrator" if $@;

        return %lock;
    }

    return ();
}

sub put_lock {
    my %lock = @_;

    use Data::Dumper;
    $Data::Dumper::Indent   = 1;
    $Data::Dumper::Sortkeys = 1;

    my $dumped_data = Data::Dumper->Dump( [ \%lock ], [qw(*lock)] );
    _print( LOCK_FILE, $dumped_data );
}
